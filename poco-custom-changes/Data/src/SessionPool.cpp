//
// SessionPool.cpp
//
// $Id: //poco/1.4/Data/src/SessionPool.cpp#2 $
//
// Library: Data
// Package: SessionPooling
// Module:  SessionPool
//
// Copyright (c) 2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/Data/SessionPool.h"
#include "Poco/Data/SessionFactory.h"
#include "Poco/Data/DataException.h"
#include <algorithm>

#include <utility>


namespace Poco {
namespace Data {


SessionPool::SessionPool(const std::string& sessionKey, const std::string& connectionString, int minSessions, int maxSessions, int idleTime):
	_sessionKey(sessionKey),
	_connectionString(connectionString),
	_minSessions(minSessions),
	_maxSessions(maxSessions),
	_idleTime(idleTime),
	_nSessions(0),
	_janitorTimer(1000*idleTime, 1000*idleTime/4)
{
	Poco::TimerCallback<SessionPool> callback(*this, &SessionPool::onJanitorTimer);
	if (_idleTime > 0) _janitorTimer.start(callback);
}


SessionPool::~SessionPool()
{
	try
	{
		if (_idleTime > 0) _janitorTimer.stop();
	}
	catch (...)
	{
		poco_unexpected();
	}
}


Session SessionPool::get()
{
	Poco::FastMutex::ScopedLock lock(_mutex);
	
	purgeDeadSessions();

	if (_idleSessions.empty())
	{
		if (_nSessions < _maxSessions)
		{
			Session newSession(SessionFactory::instance().create(_sessionKey, _connectionString));
			customizeSession(newSession);
			PooledSessionHolderPtr pHolder(new PooledSessionHolder(*this, newSession.impl()));
			StatementCacheMap statement_cachemap;
			_idleSessions.push_front(std::make_pair (pHolder, std::move(statement_cachemap)));
			++_nSessions;
		}
		else throw SessionPoolExhaustedException(_sessionKey, _connectionString);
	}
	PooledSessionHolderPtr pHolder(_idleSessions.front().first);
	PooledSessionImplPtr pPSI(new PooledSessionImpl(pHolder));
	
	_activeSessions.push_front(std::move(_idleSessions.front()));
	_idleSessions.pop_front();
	return Session(pPSI);
}


Session SessionPool::extDB_get(SessionList::iterator &itr)
{
	Poco::FastMutex::ScopedLock lock(_mutex);

	purgeDeadSessions();

	if (_idleSessions.empty())
	{
		Session newSession(SessionFactory::instance().create(_sessionKey, _connectionString));
		customizeSession(newSession);
		PooledSessionHolderPtr pHolder(new PooledSessionHolder(*this, newSession.impl()));

		StatementCacheMap statement_cachemap;
		_idleSessions.push_front(std::make_pair (pHolder, std::move(statement_cachemap)));
		++_nSessions;
	}
	PooledSessionHolderPtr pHolder(_idleSessions.front().first);
	PooledSessionImplPtr pPSI(new PooledSessionImpl(pHolder));


	_activeSessions.push_front(std::move(_idleSessions.front()));
	_idleSessions.pop_front();

	itr = _activeSessions.begin();

	return Session(pPSI);
}


void SessionPool::extDB_updateStatementCacheMap(StatementCacheMap &statement_cachemap, SessionList::iterator &itr)
{
	Poco::FastMutex::ScopedLock lock(_mutex);
	itr->second = statement_cachemap;
}


void SessionPool::purgeDeadSessions()
{
	SessionList::iterator it = _idleSessions.begin();
	for (; it != _idleSessions.end(); )
	{
		if (!(*it).first->session()->isConnected())
		{
			it = _idleSessions.erase(it);
			// TODO
			--_nSessions;
		}
		else ++it;
	}
}


int SessionPool::capacity() const
{
	return _maxSessions;
}

	
int SessionPool::used() const
{
	Poco::FastMutex::ScopedLock lock(_mutex);

	return (int) _activeSessions.size();
}

	
int SessionPool::idle() const
{
	Poco::FastMutex::ScopedLock lock(_mutex);

	return (int) _idleSessions.size();
}


int SessionPool::dead()
{
	Poco::FastMutex::ScopedLock lock(_mutex);

	int count = 0;

	SessionList::iterator it = _activeSessions.begin();
	SessionList::iterator itEnd = _activeSessions.end();
	for (; it != itEnd; ++it)
	{
		if (!(*it).first->session()->isConnected())
			++count;
	}

	return count;
}


int SessionPool::allocated() const
{
	Poco::FastMutex::ScopedLock lock(_mutex);
	
	return _nSessions;
}

	
int SessionPool::available() const
{
	return _maxSessions - used();
}


void SessionPool::customizeSession(Session&)
{
}


void SessionPool::putBack(PooledSessionHolderPtr pHolder)
{
	Poco::FastMutex::ScopedLock lock(_mutex);

	for (SessionList::iterator it = _activeSessions.begin(); it != _activeSessions.end(); ++it)
	{
		if ((*it).first == pHolder)
		{
			if (pHolder->session()->isConnected())
			{
				pHolder->access();
				_idleSessions.push_front(std::move(*it));
			}
			else
			{
				--_nSessions;
			};
			_activeSessions.erase(it);
			break;
		}
	}
}


void SessionPool::putBack(SessionList::iterator it)
{
	Poco::FastMutex::ScopedLock lock(_mutex);

	if ((*it).first->session()->isConnected())
	{
		((*it).first)->access();
		_idleSessions.push_front(std::move(*it));
	}
	else
	{
		--_nSessions;
	};
	_activeSessions.erase(it);
}


void SessionPool::onJanitorTimer(Poco::Timer&)
{
	Poco::FastMutex::ScopedLock lock(_mutex);
	
	SessionList::iterator it = _idleSessions.begin(); 
	while (_nSessions > _minSessions && it != _idleSessions.end())
	{
		if ((*it).first->idle() > _idleTime || !(*it).first->session()->isConnected())
		{	
			try
			{
				(*it).first->session()->close();
			}
			catch (...)
			{			
			}
			it = _idleSessions.erase(it);
			--_nSessions;
		}
		else ++it;
	}
}


} } // namespace Poco::Data
